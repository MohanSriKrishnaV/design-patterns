### **SOLID Principles in OOP â€“ A Beginnerâ€™s Guide** ğŸš€  
SOLID is a set of five design principles that help in writing maintainable, scalable, and flexible code.  

**S** â€“ **Single Responsibility Principle (SRP)**  
**O** â€“ **Open/Closed Principle (OCP)**  
**L** â€“ **Liskov Substitution Principle (LSP)**  
**I** â€“ **Interface Segregation Principle (ISP)**  
**D** â€“ **Dependency Inversion Principle (DIP)**  

---

## **1ï¸âƒ£ Single Responsibility Principle (SRP)**
ğŸ“Œ **Definition**: A class should have only **one reason to change**, meaning it should have **only one responsibility**.  
ğŸ“Œ **Why?** Avoids **"God classes"**, improves **modularity**, and makes debugging easier.  

### **âŒ Bad Example (Violates SRP)**
```javascript
class Book {
    constructor(title, author, content) {
        this.title = title;
        this.author = author;
        this.content = content;
    }

    saveToFile(filename) {
        console.log(`Saving ${this.title} to ${filename}`);
    }

    print() {
        console.log(`Printing ${this.title}`);
    }
}
```
ğŸ”´ **Problem:** The `Book` class **does two things** â€“  
1. Handles book data  
2. Saves/prints the book  

ğŸ“Œ **Fix:** Split responsibilities into separate classes.  

### âœ… **Good Example (Follows SRP)**
```javascript
class Book {
    constructor(title, author, content) {
        this.title = title;
        this.author = author;
        this.content = content;
    }
}

class BookPrinter {
    print(book) {
        console.log(`Printing ${book.title}`);
    }
}

class BookSaver {
    save(book, filename) {
        console.log(`Saving ${book.title} to ${filename}`);
    }
}
```
âœ… Now, **Book** only handles data, and printing/saving is handled separately.  

---

### **ğŸ“ Exercise 1 â€“ Fix SRP Violation**
The following `Employee` class violates SRP.  
âœ… **Task:** Refactor it to follow SRP.  

```javascript
class Employee {
    constructor(name, salary) {
        this.name = name;
        this.salary = salary;
    }

    calculateSalary() {
        return this.salary * 12; 
    }

    generateReport() {
        console.log(`Report for ${this.name}`);
    }
}
```
ğŸ”¹ **Hint:** Move `calculateSalary` and `generateReport` to separate classes.

---

## **2ï¸âƒ£ Open/Closed Principle (OCP)**
ğŸ“Œ **Definition**: A class should be **open for extension but closed for modification**.  
ğŸ“Œ **Why?** We should be able to **add new features without modifying existing code** (avoids breaking existing functionality).  

### **âŒ Bad Example (Violates OCP)**
```javascript
class Discount {
    applyDiscount(userType, price) {
        if (userType === "normal") {
            return price * 0.9;
        } else if (userType === "premium") {
            return price * 0.8;
        }
        return price;
    }
}
```
ğŸ”´ **Problem:** If a new user type (e.g., "VIP") is added, we **must modify** this class.  

ğŸ“Œ **Fix:** Use **polymorphism** â€“ create separate classes for different discounts.  

### âœ… **Good Example (Follows OCP)**
```javascript
class Discount {
    apply(price) {
        return price;
    }
}

class NormalDiscount extends Discount {
    apply(price) {
        return price * 0.9;
    }
}

class PremiumDiscount extends Discount {
    apply(price) {
        return price * 0.8;
    }
}
```
âœ… Now, if we add a **VIP discount**, we **donâ€™t modify old code**.  

---

### **ğŸ“ Exercise 2 â€“ Fix OCP Violation**
The `PaymentProcessor` class violates OCP.  
âœ… **Task:** Refactor it so that new payment methods can be added **without modifying existing code**.  

```javascript
class PaymentProcessor {
    processPayment(type, amount) {
        if (type === "credit") {
            console.log(`Processing credit payment of $${amount}`);
        } else if (type === "paypal") {
            console.log(`Processing PayPal payment of $${amount}`);
        }
    }
}
```
ğŸ”¹ **Hint:** Use inheritance to separate different payment types.

---

## **3ï¸âƒ£ Liskov Substitution Principle (LSP)**
ğŸ“Œ **Definition**: A subclass should **replace its parent class without breaking functionality**.  
ğŸ“Œ **Why?** Ensures **correct inheritance** â€“ subclasses should **not change** the expected behavior of the base class.  

### **âŒ Bad Example (Violates LSP)**
```javascript
class Bird {
    fly() {
        console.log("Flying...");
    }
}

class Penguin extends Bird {
    fly() {
        throw new Error("Penguins can't fly!");
    }
}
```
ğŸ”´ **Problem:** The subclass (`Penguin`) **modifies** expected behavior, **breaking** the program.  

ğŸ“Œ **Fix:** Use **composition** instead of inheritance.  

### âœ… **Good Example (Follows LSP)**
```javascript
class Bird {
    move() {
        console.log("Moving...");
    }
}

class FlyingBird extends Bird {
    fly() {
        console.log("Flying...");
    }
}

class Penguin extends Bird {
    swim() {
        console.log("Swimming...");
    }
}
```
âœ… Now, `Penguin` **doesnâ€™t break** the behavior of `Bird`.

---

### **ğŸ“ Exercise 3 â€“ Fix LSP Violation**
The following `Rectangle` and `Square` classes violate LSP.  
âœ… **Task:** Refactor them so that the subclass doesnâ€™t break the behavior of the parent class.  

```javascript
class Rectangle {
    constructor(width, height) {
        this.width = width;
        this.height = height;
    }

    setWidth(width) {
        this.width = width;
    }

    setHeight(height) {
        this.height = height;
    }

    area() {
        return this.width * this.height;
    }
}

class Square extends Rectangle {
    setWidth(width) {
        this.width = width;
        this.height = width;
    }

    setHeight(height) {
        this.width = height;
        this.height = height;
    }
}
```
ğŸ”¹ **Hint:** Instead of extending `Rectangle`, create a separate `Square` class.

---

### **ğŸ”¹ Next Steps**
Once you solve these **three exercises**, we'll move to:  
âœ… **Interface Segregation Principle (ISP)**  
âœ… **Dependency Inversion Principle (DIP)**  

ğŸ’¡ **Would you like me to check your solutions after you complete them?** ğŸš€